<html><head><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151329628-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-151329628-1');
</script>
<meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="styles/branding.css" /><link rel="stylesheet" type="text/css" href="styles/branding-en-US.css" /><script type="text/javascript" src="scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Synchronous signals</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="Neon.Temporal-Workflow-SyncSignals" /><meta name="Description" content="Ideally, you'd like your workflows to manage all of the logic for a given operation including reacting to external events. Temporal currently provides two ways for doing this: external activities and signals." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link type="text/css" rel="stylesheet" href="styles/highlight.css" /><script type="text/javascript" src="scripts/highlight.js"> </script><link rel="stylesheet" type="text/css" href="styles/branding-Website.css" /><script type="text/javascript" src="scripts/jquery-3.3.1.min.js"></script><script type="text/javascript" src="scripts/branding-Website.js"></script><script type="text/javascript" src="scripts/clipboard.min.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">Neon and neonKUBE class libraries and tools<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="index.html" title="Neon and neonKUBE class libraries and tools" tocid="roottoc">Neon and neonKUBE class libraries and tools</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="Neon.Temporal-Overview.htm" title="Neon.Temporal" tocid="5528b5b8-a2ef-4d0e-a613-0b3967d6fd4d">Neon.Temporal</a></div><div class="toclevel1" data-toclevel="1" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="Neon.Temporal-Workflow-CodingRules.htm" title="Workflow details" tocid="534d0b51-23d9-4ab9-b897-980a97592ff5">Workflow details</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-CodingRules.htm" title="Coding rules" tocid="7377a962-2a8a-498b-b9ad-2de58541bccb">Coding rules</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-IDsExecutions.htm" title="IDs &amp; executions" tocid="1e741adc-714f-4a77-82aa-ff1756ee1c9a">IDs &amp; executions</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-Scheduling.htm" title="Timeouts" tocid="b86e3e81-ffe5-4a59-b840-aebe31bd5014">Timeouts</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-ChildWorkflows.htm" title="Child workflows" tocid="fef3cdc8-41e8-4c31-a81d-a6857d202faa">Child workflows</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-GettingStarted-Parallel.htm" title="Parallel operations" tocid="82d58fc1-98ce-4872-bf3d-7530f9be1a9e">Parallel operations</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-Options.htm" title="Options" tocid="e74d1092-9a9d-429f-bbe2-7ad595d7a6fe">Options</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-Queries.htm" title="Queries" tocid="2de5ef53-412c-4f8d-b40b-69f06db7762b">Queries</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-SignalQueues.htm" title="Signals &amp; queues" tocid="fef4f5f1-ee69-479c-9321-6586ec5d45f9">Signals &amp; queues</a></div><div class="toclevel2 current" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-SyncSignals.htm" title="Synchronous signals" tocid="1284aec5-7464-4243-aa38-75366c26a031">Synchronous signals</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Activity-ContinueAsNew.htm" title="Continue as new" tocid="397dcfd2-0d7a-4148-b2a5-372f77807184">Continue as new</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="Neon.Temporal-Workflow-CRON.htm" title="Distributed CRON" tocid="fd66b149-f9e7-4ac4-90d6-64c1310b38f3">Distributed CRON</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="logoColumn"><img src="icons/Help.png" /></td><td class="titleColumn"><h1>Synchronous signals</h1></td></tr></table><span class="introStyle"></span> <div class="introduction"><div class="alert"><table><tr><th><img src="icons/AlertCaution.png" alt="Caution note" /> Caution</th></tr><tr><td><strong>EXPERIMENTAL:</strong> This is an experimental feature.  Temporal server doesn't
        currently have a synchronous way to interact with a running workflow, so the Neon Temporal client
        emulates this behavior using a combination of internal signals and queries.  This will be obsoleted
        and eventually replaced when Temporal supports this natively.
      </td></tr></table></div><p>
        Ideally, you'd like your workflows to manage all of the logic for a given operation including
        reacting to external events.  Temporal currently provides two ways for doing this: external
        activities and signals.
      </p><p>
        External activities are somewhat difficult configure and use and signals are nice, but they
        have fire-and-forget semantics, so it's impossible for a signal to indicate to the caller
        that the signal was processed by the workflow and optionally return a result providing more
        information about how the workflow handled the signal.
      </p><p>
        For example, say you've implemented this order processing workflow:
      </p><ol><li><p>
            Customer submits an order to an ecommerce website.
          </p></li><li><p>
            The website starts a workflow to process the order.
          </p></li><li><p>
            The order workflow sends a packing list to the warehouse, where the order
            will be packed and shipped.
          </p></li><li><p>
            Warehouse workers send a signal to the workflow via a mobile app after
            the delivery company picks up the package.  This signal includes the
            tracking ID.
          </p></li><li><p>
            The workflow queries the delivery company to obtain the package ETA
            and then sends an email to the customer with the tracking information.
          </p></li><li><p>
            The workflow monitors the delivery status and sends another email to
            the customer after the package is delivered.
          </p></li></ol><p>
        That's pretty straightforward, but imagine that customers are allowed to
        cancel an order up until the the time when the order is packaged for delivery.
        So, let's say the customer goes back to the website and cancels the order.  The website
        could send a standard cancel signal to the workflow but since signals are fire-and-forget,
        the website will not be able to determine whether the order was actually cancelled
        or not.  There is no way for the workflow to return this status to the website.
      </p><p>
        A workaround would be to have the website query the order database to determine
        whether it's still possible to cancel the order before sending the signal.
        Another workaround would be to have the website query the database after
        sending the signal, checking to see if the order status was changed
        to cancel.
      </p><p>
        There are two problems with both of these approaches: you'll be sprinkling
        order business logic outside of the workflow which will probably become a
        maintainece nightmare over time and its very likely these approaches will
        introduce hard to overcome race conditions.
      </p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="icons/SectionExpanded.png" />Synchronous Signals</span></div><div id="ID1RBSection" class="collapsibleSection"><p>
          The <strong>Neon.Temporal</strong> package provides a reasonable solution to
          problems like that outlined above by extending standard Temporal signals so that 
          clients sending signals will wait for the signal to be procesed by the workflow
          as well as optionally allowing signals to return a result.  This is accomplished
          by specifying <span class="code">[SignalMethod(Synchronous=true)]</span> for 
          signal method definitions in your workflow interfaces:
        </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EACADAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EACADAAA_copyCode" href="#" class="copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EACADAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EACADAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[WorkflowInterface]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">interface</span> : IMyWorkflow : IWorkflow
{
    [WorkflowMethod]
    Task MainAsync();

    [SignalMethod(<span class="highlight-literal">"standard-signal"</span>)]
    Task SignalAsync(<span class="highlight-keyword">string</span> arg);

    [SignalMethod(<span class="highlight-literal">"sync-signal-void"</span>, Synchronous = <span class="highlight-keyword">true</span>)]
    Task SyncSignal1Async(<span class="highlight-keyword">string</span> arg);

    [SignalMethod(<span class="highlight-literal">"sync-signal-with-result"</span>, Synchronous = <span class="highlight-keyword">true</span>)]
    Task&lt;<span class="highlight-keyword">string</span>&gt; SyncSignal2Async(<span class="highlight-keyword">string</span> arg);
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EACADAAA");</script><p>
          This interface defines a workflow with a main workflow method, <span class="code">SignalAsyc()</span>
          as a standard fire-and-forget signal, <span class="code">SyncSignal1Async()</span> which is a
          synchronous signal that doesn't return a result and <span class="code">SyncSignal1Async()</span>,
          a synchronous signal that does return a result.
        </p><p>
          The Neon Temporal client will include the synchronous signal methods the stubs generated
          for the workflow and you can simply call these like you would a standard signal.  The 
          difference is that the synchronous methods won't return until after the workflow has 
          actually processed the signal.  Standard signals return immediately after the signal
          has been submitted to Temporal and you'll never be sure when or even if the signal was 
          actually received and processed by the workflow.
        </p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID2RB')" onkeypress="SectionExpandCollapse_CheckKey('ID2RB', event)" tabindex="0"><img id="ID2RBToggle" class="collapseToggle" src="icons/SectionExpanded.png" />Implementation Overview</span></div><div id="ID2RBSection" class="collapsibleSection"><p>
          Neon implements synchronous signals using a combination of standard Temporal signals and queries.
          This works roughly like this:
        </p><ol><li><p>
              Your application calls a synchronous signal stub method.
            </p></li><li><p>
              The stub polls Temporal for a reasonable period of time to ensure that the
              workflow actually running.
            </p></li><li><p>
              The stub sends a standard signal to an internal signal method implemented by
              Neon.Temporal.  The signal is dispatched to your synchronous signal method
              where your logic can do its thing and then ultimately returns.
            </p></li><li><p>
              Neon.Temporal maintains an internal table tracking each synchronous signal
              received.  We track whether or not the your signal method has returned and
              also persist any result there.
            </p></li><li><p>
              After the client stub has sent the internal signal in step 2, it begins 
              polling the workflow for signal completion by sending queries to an
              internal method.  This method returns the signal status from the internal
              tracking table.  The stub will stop querying when it sees that the 
              signal method has returned.  At this point, the stub will return to
              the caller.
            </p></li></ol><p>
          This all is pretty clean, but there are some caveats:
        </p><ul><li><p>
              This is a <strong>Neon-only feature</strong>.  You can not use this to send
              synchronous signals to workflows implemented in other lanmguages like Java or Go
              (they don't support this).
            </p></li><li><p>
              By default synchronous signals will wait up to 60 seconds for the workflow
              to process a synchronous signal and return.  This relies on your workflow
              processing decision tasks promptly.  You can customize this timeout by 
              assigning a custom retry policy to 
              <a href="P_Neon_Temporal_TemporalClient_SyncSignalRetry.htm">SyncSignalRetry</a>.
            </p></li><li><p>
              Workflows that have seen synchronous signals will be delayed for a period
              of time after returning to give the client stub a chance to query for any
              pending signal results.  By default, the workflow will be delayed for a
              maximum of <strong>30 seconds</strong>.  This means that when
              a workflow will be held up for this long if the signalling client stops
              (for some reason) before all signals have been acknowledged.
            </p><p>
              You can customize this timeout via <span class="nolink">MaxWorkflowDelaySeconds</span>.
            </p></li><li><p>
              This workflow delay will also add one sleep operation per second the workflow
              is delayed to the history.  Typically, only a handful of these will be recorded.
            </p></li></ul></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="icons/SectionExpanded.png" />Implementing Synchronous Signals</span></div><div id="ID3RBSection" class="collapsibleSection"><p>
          Neon supports two approaches to implementing synchronous signal methods.
          For very simple scenarios, your signal method can simply modify the 
          workflow state by examining and setting workflow instance fields or
          properties and then returning.  The more powerful but more complex
          technique is to enqueue a <a href="T_Neon_Temporal_SignalRequest.htm">SignalRequest</a>
          or <a href="T_Neon_Temporal_SignalRequest_1.htm">SignalRequest<span id="LST95CEAC93_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_0?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TResult<span id="LST95CEAC93_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_1?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a>
          to be processed by your workflow method.
        </p><p>
          Let's look at a simple cancellation scenario first:
        </p><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EAIABAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EAIABAAA_copyCode" href="#" class="copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAIABAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAIABAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[WorkflowInterface(TaskQueue = <span class="highlight-literal">"my-tasks"</span>)]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">interface</span> IOrderWorkflow : IWorkflow
{
    [WorkflowMethod]
    Task&lt;<span class="highlight-keyword">bool</span>&gt; ProcessOrderAsync();

    [SignalMethod(<span class="highlight-literal">"cancel"</span>, Synchronous = <span class="highlight-keyword">true</span>)]
    Task&lt;<span class="highlight-keyword">string</span>&gt; CancelOrderAsync(<span class="highlight-keyword">string</span> reason);
}

[Workflow]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> OrderWorkflow : WorkflowBase, IOrderWorkflow
{
    <span class="highlight-keyword">private</span> <span class="highlight-keyword">bool</span>    cancelPending = <span class="highlight-keyword">false</span>;
    <span class="highlight-keyword">private</span> <span class="highlight-keyword">string</span>  cancelReason  = <span class="highlight-keyword">null</span>;
    <span class="highlight-keyword">private</span> <span class="highlight-keyword">bool</span>    canCancel     = <span class="highlight-keyword">true</span>;

    <span class="highlight-keyword">public</span> <span class="highlight-keyword">async</span> Task&lt;<span class="highlight-keyword">bool</span>&gt; ProcessOrderAsync()
    {
        <span class="highlight-comment">// Implements order processing.  This is probably includes</span>
        <span class="highlight-comment">// one or more loops that poll [canCancel] while it's still</span>
        <span class="highlight-comment">// possible to cancel the order.</span>

        <span class="highlight-keyword">await</span> Workflow.SleepAsync(TimeSpan.FromSeconds(<span class="highlight-number">5</span>));

        <span class="highlight-keyword">if</span> (cancelPending)
        {
            <span class="highlight-keyword">return</span> <span class="highlight-keyword">false</span>;
        }

        <span class="highlight-comment">// Cancellation is no longer alloowed.</span>

        canCancel = <span class="highlight-keyword">false</span>;

        <span class="highlight-comment">// This is where the order will be fulfilled.</span>

        <span class="highlight-keyword">await</span> Workflow.SleepAsync(TimeSpan.FromSeconds(<span class="highlight-number">5</span>));

        <span class="highlight-keyword">return</span> <span class="highlight-keyword">true</span>;
    }

    <span class="highlight-keyword">public</span> <span class="highlight-keyword">async</span> Task&lt;<span class="highlight-keyword">string</span>&gt; CancelOrderAsync(<span class="highlight-keyword">string</span> reason)
    {
        <span class="highlight-keyword">if</span> (!canCancel)
        {
            <span class="highlight-keyword">return</span> <span class="highlight-literal">"Order can no longer be be cancelled"</span>;
        }

        cancelPending = <span class="highlight-keyword">true</span>;
        cancelReason  = reason;

        <span class="highlight-keyword">return</span> <span class="highlight-keyword">await</span> Task.FromResult(<span class="highlight-literal">"Order cancelled"</span>);
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAIABAAA");</script><p>
          This is a partial implementation of an order workflow that provides a synchronous
          order cancellation signal.  Imagine in this case, that the workflow method loops
          at strategic places in its logic polling for the signal to set <span class="code">canCancel=true</span>.
          The workflow logic also sets <span class="code">canCancel=false</span> when
          cancellation is no longer possible.
        </p><p>
          The <span class="code">CancelOrderAsync()</span> synchronous signal method simply
          checks <span class="code">canCancel</span> to determine whether cancellation is 
          still possible, sets <span class="code">canCancel=true</span> when this is still
          the case, and then returns a string describing what happened.
        </p><p>
          This approach is super simple but the polling is going to add to the workflow
          history.  Another approach is to use a <a href="T_Neon_Temporal_WorkflowQueue_1.htm">WorkflowQueue<span id="LST95CEAC93_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_2?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>T<span id="LST95CEAC93_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_3?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a>
          to marshal the signal information to the workflow logic.  We're going to use the
          new generic <a href="T_Neon_Temporal_SignalRequest_1.htm">SignalRequest<span id="LST95CEAC93_4"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_4?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TResult<span id="LST95CEAC93_5"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_5?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a>
          class to make this easier.
        </p><div class="alert"><table><tr><th><img src="icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>
            Neon.Temporal also has the <a href="T_Neon_Temporal_SignalRequest.htm">SignalRequest</a>
            non-generic class that can be used for signals that don't return a result.
          </p></td></tr></table></div><div class="codeSnippetContainer"><div class="codeSnippetContainerTabs"><div id="ID0EADABAAA_tab1" class="codeSnippetContainerTabSingle">C#</div></div><div class="codeSnippetContainerCodeContainer"><div class="codeSnippetToolBar"><div class="codeSnippetToolBarText"><a id="ID0EADABAAA_copyCode" href="#" class="copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EADABAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EADABAAA_code_Div1" class="codeSnippetContainerCode" style="display: block"><pre xml:space="preserve">[WorkflowInterface(TaskQueue = <span class="highlight-literal">"my-tasks"</span>)]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">interface</span> IOrderWorkflow : IWorkflow
{
    [WorkflowMethod]
    Task ProcessOrderAsync();

    [SignalMethod(<span class="highlight-literal">"cancel"</span>, Synchronous = <span class="highlight-keyword">true</span>)]
    Task&lt;<span class="highlight-keyword">string</span>&gt; CancelOrderAsync(<span class="highlight-keyword">string</span> reason);
}

[Workflow]
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> OrderWorkflow : WorkflowBase, IOrderWorkflow
{
    <span class="highlight-keyword">private</span> WorkflowQueue&lt;SignalRequest&lt;<span class="highlight-keyword">string</span>&gt;&gt; queue;

    <span class="highlight-keyword">public</span> <span class="highlight-keyword">async</span> Task ProcessOrderAsync()
    {
        <span class="highlight-comment">// Create queue to receive signal requests from the </span>
        <span class="highlight-comment">// [CancelOrderAsync()] synchronous signal method.</span>

        queue = <span class="highlight-keyword">await</span> Workflow.NewQueueAsync&lt;SignalRequest&lt;<span class="highlight-keyword">string</span>&gt;&gt;();

        <span class="highlight-comment">// Wait for a signal request to be dequeued, and obtain the </span>
        <span class="highlight-comment">// "reason" argument.  This will be the "reason" parameter </span>
        <span class="highlight-comment">// value passed to [CancelOrderAsync()] below.</span>

        <span class="highlight-keyword">var</span> signal = <span class="highlight-keyword">await</span> queue.DequeueAsync();
        <span class="highlight-keyword">var</span> reason = signal.Arg&lt;<span class="highlight-keyword">string</span>&gt;(<span class="highlight-literal">"reason"</span>);

        <span class="highlight-comment">// This line actually specifies the result to be returned</span>
        <span class="highlight-comment">// back to the external code that sent the synchronous signal.</span>

        <span class="highlight-keyword">await</span> signal.ReplyAsync($<span class="highlight-literal">"Order cancelled due to: {reason}"</span>);
    }

    <span class="highlight-keyword">public</span> <span class="highlight-keyword">async</span> Task&lt;<span class="highlight-keyword">string</span>&gt; CancelOrderAsync(<span class="highlight-keyword">string</span> reason)
    {
        <span class="highlight-comment">// This line creates a [SignalRequest] instance that somewhat</span>
        <span class="highlight-comment">// magically initializes the [SignalRequest.Args] dictionary</span>
        <span class="highlight-comment">// with the names and values of the parameters passed to this</span>
        <span class="highlight-comment">// method.</span>
        <span class="highlight-comment">// </span>
        <span class="highlight-comment">// Note that the &lt;string&gt; generic parameter here specifies the</span>
        <span class="highlight-comment">// result type for this signal method.</span>

        <span class="highlight-keyword">var</span> signalRequest = <span class="highlight-keyword">new</span> SignalRequest&lt;<span class="highlight-keyword">string</span>&gt;();

        <span class="highlight-comment">// Enqueue the signal request such that workflow method above</span>
        <span class="highlight-comment">// can process it as part of the workflow logic.</span>

        <span class="highlight-keyword">await</span> queue.EnqueueAsync(signalRequest);

        <span class="highlight-comment">// Throwing this exception indicates to the Temporal client</span>
        <span class="highlight-comment">// that the signal result will be sent as a reply from</span>
        <span class="highlight-comment">// the workflow code via the [SignalRequest] rather than </span>
        <span class="highlight-comment">// via a result returned by this signal method.</span>
        <span class="highlight-comment">// </span>
        <span class="highlight-comment">// We understand that this is a bit odd, but this is an</span>
        <span class="highlight-comment">// experimental feature after all.  The Temporal team is</span>
        <span class="highlight-comment">// working on a new feature to handle these scenarios</span>
        <span class="highlight-comment">// cleanly.</span>

        <span class="highlight-keyword">throw</span> <span class="highlight-keyword">new</span> WaitForSignalReplyException();
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EADABAAA");</script><p>
          This (very) partial implementation of an order workflow depicts how a synchronous
          signal can interact with the workflow logic via a queue.  The workflow first
          creates a queue and then waits for a signal request to be sent by a signal
          for processing.  Here's how this works:
        </p><ol><li><p>
              When a signal is received, the signal method constructs a <a href="T_Neon_Temporal_SignalRequest_1.htm">SignalRequest<span id="LST95CEAC93_6"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_6?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TResult<span id="LST95CEAC93_7"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_7?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a>
              instance.  Via the magic of ambient state, the signal request class knows that it's within a signal
              method it intializes its <a href="P_Neon_Temporal_SignalRequest_Args.htm">Args</a>
              property to the parameters values passed to the signal.  These are keyed by parameter name.
            </p></li><li><p>
              The signal method enqueues the signal request and then throws a <a href="T_Neon_Temporal_WaitForSignalReplyException.htm">WaitForSignalReplyException</a>.
              This exception indicates that the workflow logic will handle indicating that the signal has been processed
              as well as specifying the result, if any.
            </p></li><li><p>
              The workflow method dequeues the signal request.  Note how the <span class="code">reason</span>
              signal parameter can be obtained via <a href="M_Neon_Temporal_SignalRequest_Arg__1.htm">Arg<span id="LST95CEAC93_8"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_8?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>T<span id="LST95CEAC93_9"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_9?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script></a>.
              You can also reference <a href="P_Neon_Temporal_SignalRequest_1_Args.htm">Args</a>
              which returns the complete argument dictionary.
            </p></li><li><p>
              The workflow calls <a href="M_Neon_Temporal_SignalRequest_1_ReplyAsync.htm">ReplyAsync</a>
              with the signal result when it's time for the signal to return.  Neon.Temporal handles the rest.
            </p></li></ol><p>
          This is admittedly a bit odd but it's not very complicated and it's probably the
          best we can do until Temporal supports this scenario natively.
        </p></div><div class="collapsibleAreaRegion" id="seeAlsoSection"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="icons/SectionExpanded.png" />See Also</span></div><div id="ID4RBSection" class="collapsibleSection"><h4 class="subHeading">Reference</h4><div class="seeAlsoStyle"><a href="N_Neon_Temporal.htm">Neon.Temporal</a></div><div class="seeAlsoStyle"><a href="T_Neon_Temporal_SignalRequest.htm">SignalRequest</a></div><div class="seeAlsoStyle"><a href="T_Neon_Temporal_SignalRequest_1.htm">SignalRequest<span id="LST95CEAC93_10"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_10?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TResult<span id="LST95CEAC93_11"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST95CEAC93_11?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a></div><div class="seeAlsoStyle"><a href="P_Neon_Temporal_SignalMethodAttribute_Synchronous.htm">Synchronous</a></div></div></div></div><div id="pageFooter" class="pageFooter">Offline help available for Windows: <a href="neon.chm">neon.chm</a><br />
Report any issues at: <a href="https://github.com/nforgeio/neonKUBE">https://github.com/nforgeio/neonKUBE</a><p>Copyright (c) 2005-2020 by neonFORGE LLC.  All rights reserved.</p></div></body></html>